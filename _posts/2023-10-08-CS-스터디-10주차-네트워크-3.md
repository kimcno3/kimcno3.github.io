---
layout: post
categories: CS
tags: CS
title: "[CS 스터디] 네트워크 3"
---

## 11. 3-Way Handshake에 대해 설명해 주세요.
> [참고 자료](https://blog.naver.com/is_king/221570764551)

- 3 Way-Handshake란, TCP에서 클라이언트와 서버의 확실한 연결을 보장하기 위해 거치는 세 단계 과정을 의미합니다.
- 3단계는 아래와 같이 순서대로 동작해 두 객체간의 연결을 시도합니다.
  - SYN(Client -> Server) : 클라이언트의 연결 요청으로 초기 시퀀스 넘버를 500으로 지정해 전달합니다.
  - ACK + SYN(Server -> Client) : 클라이어트의 연결 요청에 대한 서버의 응답 및 서버의 연결 요청으로 승인 번호(Acknowledgement Number)는 501, 서버의 초기 시퀀스 넘버는 250을 전달합니다.
  - ACK(Client -> Server) : 서버의 연결 요청에 대한 클라이언트의 응답으로 승인 번호는 251, 시퀀스 넘버는 501로 전달합니다.

### ACK, SYN 같은 정보는 어떻게 전달하는 것 일까요?
> [참고 자료](https://evan-moon.github.io/2019/11/10/header-of-tcp/#tcp%EC%9D%98-%ED%97%A4%EB%8D%94%EB%A5%BC-%EA%B9%8C%EB%B3%B4%EC%9E%90)

- TCP 패킷의 헤더에 플래그 값을 통해 정보를 전달합니다.
  - ACK : 승인 번호가 채워진 상태임을 알리는 플래그
  - SYN : 연결을 위해 시퀀스 넘버를 맞추기 위해 사용되는 플래그

> 그 외 플래그에 정보는 [다음 링크](https://evan-moon.github.io/2019/11/10/header-of-tcp/#flags-ns--fin)를 참고하시면 됩니다.

### 2-Way Handshaking를 하지 않는 이유에 대해 설명해 주세요.
- 클라이언트와 서버가 각자 한번의 의사로는 연결을 확정지을 수 없기 때문입니다.
- 서버 측에서 클라이언트에 대한 연결 요청을 보낸 이후, 클라이언트로부터 어떠한 확답을 받지 못한다면 연결을 보장한다고 할 수 없습니다.

### 두 호스트가 동시에 연결을 시도하면, 연결이 가능한가요? 가능하다면 어떻게 통신 연결을 수행하나요?
> [참고 자료](https://velog.io/@zh025700/%E3%85%81%ED%93%A8%ED%84%B0%EB%A7%9D#simultaneous-open)

- 두 호스트가 동시에 연결을 시도해 동시에 Connection을 맺으려고 하는 것을 Simultaneous Open 이라고 합니다.
- 이런 경우, 두 호스트가 동시에 SYN 패킷을 보내고 그에 대한 ACK+SYN를 받게 되면 연결이 완료되고 open 상태가 됩니다.

### SYN Flooding 에 대해 설명해 주세요.
> [참고 자료](https://velog.io/@dbghwns11/CS-%EC%A0%95%EB%A6%AC-11#syn-flooding-%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

- SYN Flooding은 SYN 패킷을 하나의 서버에 대량으로 전송해 서버의 자원을 고갈시키는 공격을 의미하며 서버의 리소스가 고갈되면 서버는 응답을 할 수 없어 다른 요청에 대한 처리가 불가능해집니다.
- 리소스가 고갈된다는 것은 서버가 SYN 요청을 받으면 연결 테이블에 정보를 저장한 상태로 유지되는데 공격자가 연결을 위한 ACK 요청을 보내지 않고 계속해서 SYN 요청만 보내면 테이블 용량이 부족하게 되는 것을 의미합니다.
- 해결 방법으로는 SYN 쿠킹 방식이 있습니다.

> SYN Flooding은 DoS의 일종이며 자세한 설명은 [다음 링크](https://cabbage-price-1000won.tistory.com/22)를 참고해주세요.

## 12. 4-Way Handshake에 대해 설명해 주세요.
> [참고 자료](https://www.crocus.co.kr/1362)

- 3-Way Handshake와 반대로 두 호스트 간의 연결을 종료하기 위한 과정으로 4 단계로 나뉩니다.
  - FIN(**Client** -> Server) : 연결 종료 요청 및 클라이언트가 FIN-WAIT1 상태로 변경
  - ACK(**Server** -> Client) : 클라이언트로부터 받은 FIN 요청에 대한 확인 메세지 전달 및 클라아언트는 FIN-WAIT2, 서버는 CLOSE-WAIT 상태로 변경
  - FIN(**Server** -> Client) : 연결 종료 준비가 완료되었다는 메세지 전달 및 서버가 LAST-ACK 상태로 변경
  - ACK(**Client** -> Server) : 서버의 메세지를 받은 클라이언트의 확임 메세지 전달 및 클라이언트가 TIME-WAIT 상태로 변경

### 패킷이 4-way handshake 목적인지 어떻게 파악할 수 있을까요?
- TCP 패킷 헤더의 FIN 플래그를 통해 4-way handshake 목적을 파악할 수 있습니다.

### 빨리 끊어야 할 경우엔, (즉, 4-way Handshake를 할 여유가 없다면) 어떻게 종료할 수 있을까요?
> [참고 자료](https://hojunking.tistory.com/107#Abrupt%20connection%20release(%EA%B0%91%EC%9E%91%EC%8A%A4%EB%9F%B0%20%EC%97%B0%EA%B2%B0%20%ED%95%B4%EC%A0%9C)-1)

- RST(Reset) 플래그 값을 활용해 강제 종료를 수행할 수 있습니다.
  - 송신자는 패킷을 보내고 세션을 종료하며 수신자는 패킷을 받으면 세션을 즉시 종료합니다.

### 4-Way Handshake 과정에서 중간에 한쪽 네트워크가 강제로 종료된다면, 반대쪽은 이를 어떻게 인식할 수 있을까요?
> [참고 자료](https://www.crocus.co.kr/1362)

- FIN-WAIT1, 2 상태는 Time out 설정을 통해 자동으로 반대쪽의 종료를 진행할 수 있습니다. 다만 상황에 따라 적절한 시간을 지정할 필요가 있습니다.
- CLOSE-WAIT 상태의 경우는 계속 대기하게 되는 경우가 발생할 수 있어 어플리케이션 단에서 적절한 조치가 필요합니다.

### 왜 종료 후에 바로 끝나지 않고, TIME_WAIT 상태로 대기하는 것 일까요?
> [참고 자료](https://bangu4.tistory.com/74)

- 종료 이전에 먼저 전달되었어야 하는 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등의 이유로 클라이언트에서 종료가 된 이후 뒤늦게 도착하는 경우에는 의도와 다르게 정상적인 처리가 안될 수 있습니다.
- 이를 방지하기 위해 클라이언트 측에선 세션 종료를 확정지었더라도 TIME-WAIT 상태에서 아직 처리되지 못한 잉여 패킷에 대한 처리를 위해 대기하게 됩니다.

## 13. www.github.com을 브라우저에 입력하고 엔터를 쳤을 때, 네트워크 상 어떤 일이 일어나는지 최대한 자세하게 설명해 주세요.
1. 사용자가 브라우저에 사이트 주소를 입력한다.
2. 사이트 주소에 매핑되는 IP 주소를 DNS 서버로부터 가져온다.
3. IP주소로 HTTP 요청을 보낸다.
4. 실제 사이트 서버에서 요청에 대한 응답을 보내준다.(JSON, HTML 문서)
5. 받은 응답을 브라우저가 페이지를 구성해 사용자에게 노출시켜준다.

### DNS 쿼리를 통해 얻어진 IP는 어디를 가리키고 있나요?
- DNS 쿼리란 DNS 서버에 해당 도메인 주소에 대한 IP 주소를 얻어오는 명령어라고 할 수 있습니다.
- 이 IP는 도메인 주소와 매핑되는 실제 서버의 IP 주소라고 할 수 있습니다.

### Web Server와 Web Application Server의 차이에 대해 설명해 주세요.
- 웹서버는 HTTP 기반으로 동작하면서 클라이언트의 요청에 따라 정적인 리소스를 제공하는 기능을 수행합니다. 정적인 리소스에는 HTML, CSS, JS, 이미지, 영상등의 데이터들이 있습니다.(ex. Apache)
- WAS는 웹서버 기능을 포함해 프로그램 코드를 실행해 클라이언트가 요청하는 동적인 데이터를 가공해 제공하는 역할을 수행합니다. 대표적으로 JSON 형태의 가공 데이터를 전달하는 경우, 이를 WAS가 처리해준다고 할 수 있습니다.(ex. Tomcat)

### URL, URI, URN은 어떤 차이가 있나요?
> [참고 자료](https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-URL-URI-%EC%B0%A8%EC%9D%B4#urn_uniform_resource_name)

- URI (Uniform Resource Identifier)
  - 인터넷에 있는 자원을 나타내는 유일한 주소이자 식별자를 의미합니다.
  - URI의 하위 개념으로서 URL과 URN이 존재합니다.
- URL (Uniform Resource Locator)
  - 네트워크 상에서 웹 페이지, 이미지, 동영상 등의 파일이 위치한 정보를 의미합니다.
  - 일반적으로 사이트의 도메인 주소가 URL에 해당됩니다.
  - 웹 상 뿐만 아니라 다양한 프로토콜에서 URL은 존재하며 사용될 수 있습니다.
  - URL의 내부 구성은 다음과 같습니다.
    - schema : 프로토콜 정보
    - host : IP 주소
    - port : 해당 IP 주소의 서버에서 사용할 포트번호
    - url-path : 자원이 존재하는 하위 디렉토리 정보
- URN(Uniform Resource Name)
  - 네트워크 상의 자원에 대한 고유한 이름을 부여한 것을 의미합니다.
  - 프로토콜이 지정되지 않고 포함되지 않습니다.
  - 자원에 대해 영속적이고 유일하게 지정됩니다.

## 14. DNS에 대해 설명해 주세요.
- DNS(Domain Name System)는 사람이 구분하기 어려운 형태의 IP 주소를 보다 쉬운 형태의 문자열로 변환해 사용할 수 있도록 해주는 시스템이라고 할 수 있습니다.
- 문지열로 구성되는 주소는 도메인 주소라고 하며 이 주소와 매핑이 되는 실제 서버의 IP 주소를 DNS 서버(또는 네임서버)가 가지고 있어 도메인 주소로 요청을 보내게 되면 도메인 주소가 이와 매핑되는 IP 주소로 변환해주는 역할을 합니다.

### DNS는 몇 계층 프로토콜인가요?
- 실제 브라우저에서 입력된 도메인 주소를 IP 주소로 변환해주기 때문에 Application 계층이라고 할 수 있습니다. 사용자 인터페이스와 상호 소통을 통해 동작한다고 볼 수 있기 때문입니다.

### UDP와 TCP 중 어떤 것을 사용하나요?
- UDP를 사용합니다.
- 작은 형태의 DNS 쿼리를 전달하고 빠른 속도로 IP를 조회해 오는 것에 중점을 두기 때문이라고 할 수 있습니다.

### DNS Recursive Query, Iterative Query가 무엇인가요?
- Recursive Query란 도메인 주소로 요청을 보낸 클라이언트랑 DNS Recursor간의 주고받는 실제 요청 또는 응답에 대한 결과값을 의미합니다.
- 이에 반해 Iterative Query란 DNS Recursor와 네임서버 사이에 발생하는 쿼리라고 할 수 있습니다. 실제 네임 서버는 계층적 구조로 분리되어 동작 및 관리하도록 설계되어 있어 루트 서버부터 순차적으로 Iterative Query를 보내 찾고자 하는 IP 주소를 탐색하도록 동작합니다.

> Recursive Query는 왜 이름이 재귀적이라는 이름이 붙은 건가..?

> DNS Recursor는 클라이언트와 네임 서버의 중간에 위치해 중계자 역할을 하는 서버라고 이해할 수 있습니다.

### DNS 쿼리 과정에서 손실이 발생한다면, 어떻게 처리하나요?
- 기본적으로 UDP를 사용하므로 일정 시간이 지나면 재시도를 통해 손실에 대한 처리 방법이라고 할 수 있습니다.
- 재시도 횟수도 반복될수록 시간이 늘어나므로 네트워크 혼잡 자체를 줄이는 방식을 채택합니다.

### DNS 레코드 타입 중 A, CNAME, AAAA의 차이에 대해서 설명해주세요.
> [참고 자료](https://win100.tistory.com/360)

- A : 실제 연동할 IP 주소를 의미합니다. 이는 IPv4 주소를 가집니다.
- AAAA(쿼드 A 레코드) : A 타입과 동일하지만 IPv6 주소를 가집니다. 
- CNAME : 대체 도메인 값으로, 연동하고자 하는 도메인과 연동될 다른 도메인 주소를 의미합니다.

### hosts 파일은 어떤 역할을 하나요? DNS와 비교하였을 때 어떤 것이 우선순위가 더 높나요?
> [참고 자료](https://lecor.tistory.com/78)

- hosts 파일은 로컬 컴퓨터 내에서 네임서버의 역할을 수행하기 위한 정보가 저장된 파일을 의미합니다.
- 127.0.0.1을 localhost로 지정할 수 있는 이유가 hosts 파일에 해당 두 주소가 매핑되어 저장되었기 때문입니다.
- DNS 서버로 요청을 보내기 전에 hosts 파일과 local DNS cache에 우선 조회를 하기 때문에 hosts 파일이 DNS 서버보다 우선순위가 높다고 할 수 있습니다.

## 15. SOP 정책에 대해 설명해 주세요.
> [참고 자료](https://yoo11052.tistory.com/139)

- SOP(Same Origin Policy)란 브라우저가 하나의 출처(Origin)를 통해 로드된 Document 또는 Script가 다른 출처의 리소스와 상호작용 할 수 있는 방법을 제한하는 보안 메커니즘이라고 할 수 있습니다.
- 즉, A 서버에서 가져온 HTML 파일 내에서 B 서버에 대한 요청은 브라우저 단에서 제한을 둔다는 의미입니다.
- 이는 악성 스크립트와 같은 방식을 활용해 브라우저 내에서 클라이언트 인증 정보를 탈취해 해킹 목적으로 사용되는 서버로의 요청이 전달되어 정보가 악용되는 것을 방지하기 위한 정책이라고 할 수 있습니다.

### CORS 정책이 무엇인가요?
- CORS(Cross Origin Resource Sharing)는 SOP와 반대로 다른 출처의 리소스 간에 요청/응답 처리가 가능하도록 허용하는 정책입니다.
- 요청을 보내는 데이터의 헤더에서 CORS 옵션을 허용으로 변경하면 다른 Origin이라도 데이터 교환이 가능해집니다.
- 브라우저 단에서 SOP를 디폴트로 제한하기 때문에 필요에 따라서 CORS를 허용해 다른 출처에서 응답을 받는 형태로의 웹구현이 가능합니다.
- 즉, CORS를 지킨 요청이라면 다른 출처의 서버로 요청이 가능하다고 표현할 수 있습니다.

### Preflight에 대해 설명해 주세요.
> [참고 자료](https://kk3june.tistory.com/45)

- Preflight는 CORS가 동작하는 세가지 시나리오 중 하나로 실제 요청을 보내기 전에 예비 요청을 통해 보내고자 하는 서버가 안전한 서버인지 브라우저가 스스로 확인하는 방식입니다.
- Preflight가 동작하는 방식은 다음과 같습니다.
  - 브라우저는 요청을 보내고자 하는 서버에 다음 정보를 요청 헤더에 담아 보냅니다.
    - Origin : 요청을 보내는 출처 URL
    - Access-Control-Request-Headers : 실제 요청의 메서드 값
    - Access-Control-Request-Method : OPTIONS(대상 리소스에 대한 통신 가능 옵션을 설명) - Preflight 요청이라는 의미를 가지는 메소드라고 이해할 수 있습니다.
  - 서버는 Origin값을 가지고 해당 출처에 대한 응답 가능 여부를 확인하고, 유효하다면 응답 객체 헤더에 다음 정보를 담아 브라우저에게 보내줍니다.
    - Access-Control-Allow-Origin : 서버측 허가 출처
    - Access-Control-Allow-Headers : 서버측 허가 헤더(ex. content-type)
    - Access-Control-Allow-Methods : 서버측 허가 메소드 종류
    - Access-Control-Max-Age : 응답 캐시 시간
  - 만약 서버의 응답 헤더에 위 값들이 포함되어 있지 않다면(?) CORS 에러를 반환해 실제 요청을 보내지 않고, 응답 헤더 값이 유효하다면 실제 요청을 보내게 됩니다.

> Preflight 요청이 유효하지 않다는 것을 서버가 판단하는지 아니면 브라우저가 판단하는건지?

## 16. Stateless와 Connectionless에 대해 설명해 주세요.
> [참고 자료](https://velog.io/@duarufp06/HTTP-Stateless-Connectionless-HTTP-%EB%A9%94%EC%8B%9C%EC%A7%80-%EA%B0%9C%EB%85%90)

- Stateless는 서버가 클라이언트의 이전 상태를 기억하고 있지 않는다는 것을 의미합니다. 즉, 연속적으로 동일한 클라이언트로부터 요청을 받더라도 서버는 클라이언트에 대한 정보를 요청마다 요구하는 상태가 stateless하다고 할 수 있습니다.
- Connectionless는 클라이언트의 요청에 대한 서버의 응답을 전달한 다음, 두 객체 간의 연결을 끊는 것을 의미합니다.

### 왜 HTTP는 Stateless 구조를 채택하고 있을까요?
> [참고 자료](https://velog.io/@duarufp06/HTTP-Stateless-Connectionless-HTTP-%EB%A9%94%EC%8B%9C%EC%A7%80-%EA%B0%9C%EB%85%90)

- 서버의 확장성을 보장하기 위함입니다.
- 서버의 입장에서 클라이언트의 정보를 저장하게 된다면 서버의 수를 늘렸을 경우, 다른 서버에선 클라이언트의 정보에 대해서 유지하지 않을 수 있으므로 정확한 요청을 처리하지 못하는 경우가 발생할 수 있습니다.
- 이러한 문제를 방지하기 위해 HTTP 통신에선 클라이언트는 요청마다 자신의 정보를 서버에 전달해 어느 서버가 요청을 처리하더라도 정확한 클라이언트의 요청을 처리하도록 하기 위해 stateless한 성격을 유지합니다.

> Connectionless 구조 채택 이유는 연결 유지로 인한 오버헤드를 감소시키기 위함입니다. 
> 다시 말해, HTTP 환경이 방대해지면서 여러 클라이언트로 부터 많은 요청을 처리하는데 있어 연결을 유지하는데 드는 비용이 매우 커졌기 때문에 이러한 비용을 감소시키기 위함이라고 할 수 있습니다.

### HTTP Persistence Connection 이 무엇인가요?
> [참고 자료](https://etloveguitar.tistory.com/137)

- 하나의 TCP 연결 내에서 여러 HTTP 요청을 처리하는 것을 의미합니다. TCP connection을 맺은 경우, 요청에 대한 응답을 받으면 close 하는 것이 기본이지만 필요에 따라 연결을 close 하지 않고 상태를 유지하는 것을 의미합니다.
- HTTP Persistence Connection의 장점은 다음과 같습니다.
  - 요청마다 진행하던 3-way handshake를 반복적으로 처리하지 않아 그만큼의 성능상 이점을 가져올 수 있습니다.
  - 하나의 커넥션으로 여러 요청을 처리하므로 네트워크 내에서 통신 혼잡성이 낮아집니다.
- 하지만 이는 필요에 따라 동일한 서버에 여러 클라이언트가 반복적으로 요청을 보내야 하는 특수한 상황에 고려해 볼 수 있으며, 무분별한 커넥션의 유지는 오히려 오버헤드를 유발할 수 있다는 단점이 있습니다.

### TCP의 keep-alive와 HTTP의 keep-alive의 차이는 무엇인가요?
> [참고 자료](https://velog.io/@realsnoopso/HTTP-Persistence-Connection#tcp%EC%9D%98-keep-alive%EC%99%80-http%EC%9D%98-keep-alive%EC%9D%98-%EC%B0%A8%EC%9D%B4)

- TCP keep-alive : TCP 연결 자체를 유지하는 매커니즘
- HTTP keep-alive : 하나의 TCP 연결 내에서 여러 요청에 대한 응답을 처리하는 매커니즘

## 17. 라우터 내의 포워딩 과정에 대해 설명해 주세요.
- 라우팅 알고리즘을 통해 생성된 포워딩 테이블에서 최적의 경로에 해당하는 라우터로 패킷을 이동시켜 줍니다.

### 라우팅과 포워딩의 차이는 무엇인가요?
> [참고 자료](https://nenunena.tistory.com/52)

- 라우팅(Routing)이란 패킷이 도착지까지 이동하기 위한 최적의 이동 경로를 지정하는 것을 의미하며 라우팅 알고리즘을 통해 포워딩 테이블(또는 라우팅 테이블)을 생성하는 작업입니다.
- 포워딩(Forwarding)이란 라우터의 입력 포트에서 출력 포트로 패킷을 이동시키는 것을 의미하며 포워딩 테이블을 참조해 패킷을 이동시켜주는 작업입니다.

### 라우팅 알고리즘에 대해 설명해 주세요.
> [참고 자료](https://code-lab1.tistory.com/37)

- 라우팅 알고리즘은 중앙 집중 또는 분산 형태로 구분해 볼 수 있습니다.
  - 중앙 집중형 라우팅 알고리즘
    - 네트워크 전체에 대한 정보를 가지고 최저 비용 경로를 선정합니다. 
    - 즉 모든 라우터가 연결 상태 및 비용을 알고 있으며 링크 비용 정보가 중앙 집중식으로 관리됩니다.
    - 주로 다익스트라 알고리즘을 사용합니다.
  - 분산 라우팅 알고리즘
    - 라우터들은 자신과 인접한 라우터에 대한 링크 비용 정보를 가지고 있는 상태로 최저 비용 경로를 선정합니다.
    - 최저 비용 경로 계산은 각 라우터들에 의해 반복적이고 분산된 형태로 수행하게 됩니다.
    - 주로 벨만-포드 알고리즘이 사용됩니다.

- 또한 정적 또는 동적 형태로도 구분해 볼 수 있습니다.
  - 정적 라우팅 알고리즘
    - 경로가 느리게 변화되며 사람이 직접 링크 비용을 수정합니다.
  - 동적 라우팅 알고리즘
    - 네트워크 부화 정도나 topology(라우터 간의 링크 비용에 대한 정보)의 변화에 따라 라우터가 자체적으로 경로를 변경합니다.
    - 변경 여부는 주기적으로 체크하는 방식으로 수행됩니다.

- 그래서 중앙 집중형 / 정적 라우팅 알고리즘의 경우, 네트워크 규모가 작은 구조에 적합한 형태라고 볼 수 있고 반대로 분산 / 동적 라우팅 알고리즘의 경우, 네트워크 규모가 큰 구조에서 적하바한 형태의 알고리즘이라고 할 수 있습니다.

> 굳이 중앙 집중형 알고리즘에선 다익스트라, 분산형에서 벨만-포드를 사용하는 이유가 있을까..?

### 포워딩 테이블의 구조에 대해 설명해 주세요.
> [참고 자료](https://nenunena.tistory.com/52 )

- 포워딩 테이블이 가지는 데이터는 아래와 같습니다.
  - 목적지 주소(IP Address)
  - 다음 홉에 대한 정보(즉, 다음 라우터에 대한 데이터)
  - 출력 포트
  - 서브넷 마스크

> **라우팅 테이블과 포워딩 테이블은 같은 개념인가? 다른개념인가?**
> - [참고자료 1](https://moleman.tistory.com/560) : 엄밀히 다른 메모리를 가지고 저장되지만 대부분의 경우 같은 데이터를 저장하기에 개념적으로 동일시 본다. 
> - [참고자료 2](https://nenunena.tistory.com/52) : 라우팅 과정에서 생성되기에 라우팅 테이블이라고 부르고 포워딩에 사용되기 때문에 포워딩 테이블이라고도 부른다.

## 18. 로드밸런서가 무엇인가요?
> [참고 자료](https://aws.amazon.com/ko/what-is/load-balancing/)

- 로드 밸런서는 애플리케이션을 지원하는 리소스에 네트워크 트래픽을 균등하게 배포하는 역할을 수행하는 디바이스 또는 소프트웨어를 의미합니다.
- 로드 밸런서를 사용하면서 얻을 수 있는 이점은 다음과 같습니다.
  - 가용성 : 서버 다운과 같은 문제를 로드 밸런서가 감지하고 접근을 제어해 문제를 방지할 수 있습니다.
  - 확장성 : 서버의 수를 늘리더라도 로드 밸런서가 적절한 트래픽 분산을 지원해 자유롭게 서버를 확장할 수 있습니다.
  - 보안 : 서버로 접근하는 트래픽을 모니터링해 서버 장애를 일으킬 수 있는 악성 트래픽을 감지해 방어할 수 있습니다.
  - 성능 : 서버의 과부화를 방지함으로써 서버의 응답시간과 네트워크 지연 시간을 줄여줄 수 있습니다.

### L4 로드밸런서와, L7 로드밸런서의 차이에 대해 설명해 주세요.
> [참고 자료](https://dodghek.tistory.com/33)

- **L4 로드 밸런서**
  - 4 계층인 네트워크 계층 위에서 동작하는 로드 밸런서로 IP, port 만을 가지고 분산 처리를 지원합니다.
  - 으로 인해 모든 서버는 스펙을 다를 수 있지만 동일한 요청에 대한 처리를 해줄 수 밖에 없습니다.
- **L7 로드 밸런서**
  - 7 계층 위에서 동작하는 로드 밸런서로써, IP, port 뿐 만 아니라 URI, HTTP Header, Cookie와 같은 어플리케이션 단에서의 정보를 가지고 분산처리가 가능합니다.
  - 이로 인해 모든 서버가 동일한 작업을 하는 것이 아니라 서비스 별로 서버를 분리해 구축하고 클라이언트의 요청의 종류에 따라 해당 서비스를 처리하는 서버로 분산처리가 가능합니다.
  - 이로 인해 서비스적인 측면에서 서버의 확장이 좀 더 유연하게 가능해질 수 있습니다.(인증 서버는 적게 두고, 결제 서버는 많이 두고..이런 식으로)

### 로드밸런서 알고리즘에 대해 설명해 주세요.
> [참고 자료](https://aws.amazon.com/ko/what-is/load-balancing/), [참고 자료 2](https://co-no.tistory.com/22)

- 로드 밸런서 알고리즘은 크게 두가지 범주로 나뉩니다.
  - **정적 로드 밸런싱** : 고정된 규칙에 따라 분산 처리하는 방식으로 서버의 상태를 고려하지 않습니다.
    - 라운드 로빈 : 하나의 서버 팜에 있는 서버 IP 주소를 순서에 따라 차례대로 할당하는 방식입니다.
    - 가중 기반 라운드 로빈 : 우선순위 또는 용량에 따라 각 서버에 서로 다른 가중치를 할당하고 가중치가 높은 서버를 우선적으로 할당하는 방식입니다.
    - IP 해시 방식 : 클라이언트 IP 주소를 해싱 과정을 거쳐 특정 서버에 매핑하는 방식으로 처리해주는 서버를 고정시키는 방식입니다.
  - **동적 로드 밸런싱** : 서버 할당 전 서버의 상태를 검사하고 할당하는 방식입니다.
    - 최소 연결 방법 : 클라이언트의 요청이 들어온 시점에서 클라이언트와의 커넥션이 가장 적은 서버를 확인하고 할당하는 방식입니다.
    - 가중치 기반 최소 연결 방법 : 일부 서버가 다른 서버보다 많은 처리를 할 수 있는 경우, 서버마다 다른 가중치를 계산해 용량별 커넥션 수가 가장 적은 서버를 할당하는 방식입니다.
    - 최소 응답 시간 방법 : 서버의 연결 상태와 응답 시간을 고려해 가장 빠른 처리 시간을 가지는 서버를 할당하는 방식입니다.
    - 리소스 기반 방법 : 에이전트라는 소프트웨어가 서버별로 동작해 현재 서버의 리소스 사용 정도를 모니터링해 부하를 계산하고 계산 결과에 따라 서버를 할당하는 방식입니다.

- 개인적인 의견으로 두 방식의 차이점은 다음과 같습니다.
  - 정적 알고리즘의 경우, 고정적 규칙을 사용해 더 적은 리소스 활용으로 분산 처리가 가능할 것이지만 비효율적인 분산처리가 될 가능성이 있고 동적 알고리즘의 경우, 트래픽에 따라 서버의 상태를 확인하는 오버헤드가 발생하지만 정적 알고리즘에 비해 더 효율적인 분산 처리가 가능할 것이라 생각됩니다.
  - 또한 동일한 스펙의 서버 리소스를 구성하는 경우라면 정적 로드 밸런싱 기법이 적합할 것으로 보이며 서버 별로 처리할 수 있는 트래픽 정도가 다른 경우라면 동적 로드 밸런싱 기법이 적합할 것으로 보입니다.

### 로드밸런서 장치를 사용하지 않고, DNS를 활용해서 유사하게 로드밸런싱을 하는 방법에 대해 설명해 주세요.
> [참고 자료](https://www.cloudflare.com/ko-kr/learning/performance/what-is-dns-load-balancing/), [참고 자료 2](https://jaehoney.tistory.com/164)

- DNS를 활용한 로드 밸런싱의 동작 방식은 다음과 같습니다.
  1. 하나의 도메인에 A 레코드로 여러 IP 주소를 연동합니다.(각각의 IP 주소는 각각의 서버 주소입니다.)
  2. 클라이언트가 도메인으로 요청을 보내면 네임 서버는 라운드 로빈 방식으로 하나의 IP 주소를 할당해 요청을 전달합니다.
  3. 여러 클라이언트가 요청을 보낼 때 마다 네임 서버는 각기 다른 IP 주소를 할당해 트래픽을 분산해 줍니다.
- DNS 로드 밸런싱을 사용하게 되면 별도의 로드 밸런서를 두지 않고 간단한 형태로 분산 처리가 가능합니다.
- 하지만 클라이언트가 DNS의 결과를 캐싱하면서 하나의 서버에 고정되면서 효과적인 분산처리가 동작하지 않을 수 있으며 로드 밸런서가 해주는 서버 문제에 대한 모니터링과 방지의 역할을 수행하지 못합니다.

## 19. 서브넷 마스크와, 게이트웨이에 대해 설명해 주세요.
> [참고 자료]https://rangerang.tistory.com/49)

- **서브넷 마스크**
  - 서브넷 마스크는 IP 주소 내에서 어디까지가 네트워크 주소이고 어디까지가 호스트 주소를 의미하는지 그 범위의 기준을 정해주는 값이라고 할 수 있습니다.
  - 네트워크 주소는 호스트들의 집합을 의미하는 주소이며 호스트는 각각의 통신 장비에 할당되는 번호입니다.
  - 네트워크 주소와 호스트 주소는 목적과 상황에 따라 변경될 수 있으므로 서브넷 마스크를 함꼐 명시해야 정확한 네트워크에 포함된 호스트로 접근할 수 있습니다.
- **게이트웨이**
  - 게이트웨이는 다른 네트워크와 통신하기 위해 필요한 출구이며 기본 게이트웨이로는 라우터의 사설 IP 주소를 게이트웨이 주소로 사용합니다.
  - 하나의 라우터에 연결되어 있는 호스트들은 외부 네트워크와 통신하기 위해 라우터의 게이트웨이로 요청 데이터를 전송하게 되고 라우터는 받은 데이터를 외부 네트워크로 전달해 응답값을 받아 다시 해당 호스트로 전달해줍니다.

### NAT에 대해 설명해 주세요.
> [참고 자료](https://www.youtube.com/watch?v=ctY8VtRd7cc)

- NAT(Network Address Translation)는 사설 IP 주소를 공인 IP 주소로 변경해 다른 네트워크와 통신이 가능하도록 해주는 장치를 의미합니다.
- NAT가 하는 역할은 구체적으로 설명하면 다음과 같습니다.
  - 외부로 요청을 보내는 장치의 사설 IP주소를 저장합니다.
  - 사설 IP 주소를 공인 IP로 변환합니다.
  - 이후 외부 네트워크의 응답 또한 변환해준 공인 IP로 전달받고 NAT가 다시 사설 IP로 변환해주면서 원활한 통신이 가능하게 해줍니다.

### 서브넷 마스크의 표현 방식에 대해 설명해 주세요.
> [참고 자료](https://learn.microsoft.com/ko-kr/troubleshoot/windows-client/networking/tcpip-addressing-and-subnetting#ip-addresses-networks-and-hosts)

- 만약 서브넷마스크가 255.255.255.0 이라는 것은 2진법으로 풀어보면 11111111.11111111.11111111.00000000로 표현됩니다.
- 여기서 1에 해당하는 범위까지가 네트워크 주소에 사용되는 비트수이고 0에 해당하는 범위가 호스트 주소에 사용되는 범위를 의미한다고 할 수 있습니다.

### 그렇다면, 255.0.255.0 같은 꼴의 서브넷 마스크도 가능한가요?
> [참고 자료](https://bumday.tistory.com/19)

- 연속적으로 1과 0이 표현되어야 하므로 위와 같은 서브넷 마스크는 불가능합니다.

> 또한 서브넷 마스크의 범위에 따라 A~C 클래스 네트워크로 분류해 관리하고 있어 위와 같은 서브넷 마스크를 사용하는 것은 사회적 약속(?)에도 어긋나지 않나 생각합니다.(지극히 개인적인 의견..)

## 20. 멀티플렉싱과 디멀티플렉싱에 대해 설명해 주세요.
> [참고 자료](https://onduway.tistory.com/8)

- 멀티플렉싱은 송신 측 컴퓨터에 있는 여러 어플리케이션들이 전송 계층으로 메세지를 전송하게 되면 전송계층에선 하나의 통로로 여러 메세지는 일렬로 전달하는 것을 의미합니다.
- 디멀티플렉싱은 수신 측 컴퓨터의 전송 계층에서 일렬로 받아온 메세지를 각각의 어플리케이션 소켓에 전달하는 것을 의미합니다.

### 디멀티플렉싱의 과정에 대해 설명해 주세요.
> [참고 자료](https://onduway.tistory.com/8)

- 각각의 메세지에는 송신 측 전송 계층이 헤더를 붙혀 캡슐화해 전달(멀티플렉싱)하면 수신 측 전송 계층은 이 헤더를 가지고 메세지를 분리해 전달(디멀티플렉싱)하게 됩니다.
- 또한 디멀티플렉싱 과정에서는 출발지 IP와 포트 번호, 목적지 IP와 포트 번호가 필요하며 이 정보를 바탕으로 전송 계층에서 데이터를 분리합니다. 

## 21. XSS에 대해서 설명해 주세요.  
> [참고 자료](https://easymedia.net/Culture/EasyStory/?no=170&mode=view&IDX=1165&p=1), [참고 영상](https://www.youtube.com/results?search_query=xss+csrf+%EC%B0%A8%EC%9D%B4%EC%A0%90)

- XSS(Cross-Site Scripting)란 웹 상에서 존재하는 기초적인 취약점 공격 중 하나로 공격자가 악의적인 목적을 가진 스크립트 코드를 삽입해 특정 사용자가 해당 코드를 브라우저에서 실행하도록 하는 것을 의미합니다.
- 삽입된 코드를 의도치 않게 실행하게 되면 의도하지 않은 동작을 실행시키거나 공격 당하는 사용자의 브라우저에 저장된 쿠키 정보를 공격자의 서버로 탈취하는 경우가 발생할 수 있습니다.
- 코드를 삽입하는 방법은 다음과 같습니다.
  - **Stored XSS**
    - 게시물 등록과 같은 사용자가 입력한 값을 DB에 저장하고 저장한 값을 사용해 HTML 파일을 리턴해 주는 경우, 게시물 내용에 스크립트를 기재해 악성 스크립트 코드를 삽입하는 방식입니다.
  - **Reflected XSS**
    - 공격자가 제 3의 매체(이메일, 문자 등)을 통해 링크를 전달해 해당 링크를 클릭하게 되면 파라미터 값에 기재된 악성 스크립트를 그대로 리턴 HTML에 삽입하는 방식입니다.
    - 주로 피싱 방식으로 사용되며 DB에 스크립트 값이 저장되지 않고 url을 누르고 응답값에 '반사'되는 방식입니다.

> 그래서 브라우저에선 CORS를 통해 Origin 서버에서 제 3의 서버로 요청보내는 것을 사전에 방지하는 것입니다.

### CSRF랑 XSS는 어떤 차이가 있나요?
- CSRF(Cross Site Request Forgery attack)는 특정 서버에 인증된 사용자로부터 특정 요청을 공격자의 의도에 따라 보내는 것을 의미합니다.
- 서버 입장에선 클라이언트가 이미 인증된 상태이므로 받은 요청에 대해서 의심하지 않고 처리하게 되며 실제 사용자의 의도가 아닌 공격자의 의도로 보내진 요청이라도 정상처리하게 됩니다.
- 예를 들어, 공격자의 악성 스크립트 코드가 포함된 링크를 사용자가 클릭하는 순간 사용자의 쿠키 정보를 가지고 공격자에게 송금하라는 요청을 은행 서버에 보내면, 은행 서버는 인증된 쿠키 정보를 가진 요청이므로 의심하지 않고 공격자에게 송금을 하게 됩니다.
- CSRF와 XSS의 구체적인 차이점은 다음과 같습니다.
  - XSS는 클라이언트에 대한 공격이라면 CSRF는 서버에 대한 공격입니다.
  - 다시 말해, XSS가 클라이언트가 서버에 대한 신뢰를 가지고 있는 상황을 노린 공격이며 CSRF는 서버가 클라이언트에 대한 신뢰를 가지고 있는 상황을 노린 공격입니다.

### XSS는 프론트엔드에서만 막을 수 있나요?
> [참고 영상](https://www.youtube.com/watch?v=bSGqBoZd8WM&t=249s)

- XSS의 해결 방법은 다음과 같습니다.
  1. XSS 취약점이 있는 innerHTML 사용 자제
  2. 쿠키의 HTTPOnly 옵션 활성화
    - 활성화를 하게 되면 쿠키에 대한 접근을 스크립트 코드로는 불가능해집니다.
  3. XSS 특수문자를 치환
    - 스크립트 코드에 사용되는 문자를 치환해 스크립트 코드가 실행되지 않도록 할 수 있습니다.
    - Spring Lucy XSS Servlet Filter와 같은 오픈 라이브러리가 있어 직접 구현하지 않고 적용할 수 있습니다.

- 3번 방식은 프론트만 아니라 백엔드 파트에서도 방지할 수 있는 방법을 제공하고 있습니다.
