---
layout: post
title: Kotlin 기초 1
subheading:
categories: Kotlin
tags:  Kotlin
---

## 1. 코틀린에서 변수를 다루는 방법
---
1. 변수 타입 종류
   - var : 가변 변수
   - val : 불변 변수 (= `final`)
2. 변수 특성
   - var, val 모두 최초 한번은 초기값 할당이 가능하다.
   - val의 경우, element 추가는 가능하다.(final List 객체에서 add()가 가능한 것처럼!)
3. `?` 키워드
   - null 값 가능 여부를 지정
   - 코틀린에서 변수는 기본적으로 null 값이 불가능 하도록 구현
4. 구현 클래스 객체 생성시
   - new 예약어를 사용하지 않고 선언
   
위 개념을 토대로 자바 코드를 변경한 코틀린 코드는 아래와 같다.

### 자바 코드
```java
public class Lec01 {

  public static void main(String[] args) {
    long number1 = 10L;
    final long number2 = 10L;

    Long number3 = 1_000L;
    Person person = new Person("김선호");
  }

}
```

### 코틀린 코드
```kotlin

class Lec01 {
    fun main() {
        // 기본 변수 선언 방법
        var number1 = 5L // var : 가변 변수
        val number2 = 5L // val : 불변 변수

        // 초기값 미지정 시
        var number3 : Long // 변수 지정을 안하면 에러가 발생
        number3 = 5
      
        val number3 : Long
        number3 = 5 // val의 경우도 최초 한번은 초기값 할당 가능
      
        val number3 : Long = 5 // 위보단 해당 코드로 적는 것이 적절
        
        // ? 예약어 사용 시
        var numberNull : Long? = null // ?가 타입 뒤에 있어야만 null 선언 가능

        // 구현 클래스 객체 생성시
        var person = Person("김선호")
        var person2 : Person = Person("김선호")
    }
}
```

> **Tip**<br>
> 최대한 변수는 val 타입으로 선언하고 필요에 따라 var 타입으로 선언해 사용하자.(디버깅시 쉬운 구조를 생성하기 위해서)
>
> 코틀린에서는 Primitive / Reference Type에 대한 구분이 없고 내부적으로 적절히 사용하도록 코틀린이 처리해준다.

## 2. 코틀린에서 null을 다루는 방법
---
코틀린에선 null을 별도의 타입으로 간주하고 처리한다. 그래서 null값을 다루는 여러 방법에 대해 이해가 필요하다.

아래 코드는 함수의 매개변수로 null이 들어온 경우 다른 처리 방법을 표현하고 있다.

### 자바 코드
```java
public class Lec02 {

  public boolean startsWithA1(String str) {
    if (str == null) {
      throw new IllegalArgumentException("null이 들어왔습니다"); // 에러 처리
    }
    return str.startsWith("A");
  }


  public Boolean startsWithA2(String str) {
    if (str == null) {
      return null; // null 그대로 리턴
    }
    return str.startsWith("A");
  }


  public boolean startsWithA3(String str) {
    if (str == null) {
      return false; // false 리턴
    }
    return str.startsWith("A");
  }

}

```

위 세가지 경우를 코틀린 코드로 변경하기 위해선 아래 개념에 대한 이해가 필요하다.

- **Safe Call(`?.`)** : 특정 객체가 null인 경우, 함수를 호출해도 null로 리턴
- **Elvis 연산자(`?:`)** : 특정 함수의 리턴값이 null일 경우 대체 리턴값을 지정

### 코틀린 코드
```kotlin

fun startsWithA1(str : String?) : Boolean {
    return str?.startsWith("A")
        ?: throw IllegalArgumentException("null이 들어왔습니다")
}

fun startsWithA2(str : String?) : Boolean? { // null값으로 리턴이 가능해야 하기 때문에 Boolean에 ? 예약어 사용
    return str?.startsWith("A")
}

fun startsWithA3(str : String?) : Boolean {
    return str?.startsWith("A") ?: false
}
```

추가적으로 null 처리와 관련된 개념은 아래와 같다.

- **!! 단언(`!!`)** : nullable한 객체임에도 불구하고 null이 없다고 단언하는 개념
  ```kotlin
  fun startsWithA4(str : String?) : Boolean {
      return str!!.startsWith("A") // nullable한 변수이지만 절대 null이 들어올 수 없는 경우 사용
  }
  ```
  > 하지만 매개변수에서 null 이 들어올 수 있기 때문에 null 상태에서 !! 를 만나면 NPE를 터뜨리므로 확실한 경우 아니면 사용하지 않는 것을 추천

- **플랫폼 타입** : 코틀린이 null 관련 정보를 알 수 없는 타입을 의미
 > 자바로 구현된 타입을 코틀린에서 호출하는 경우, `@Nullable`이나 `@NotNull`과 같은 어노테이션이 적용되어 있지 않은 경우는 코틀린에서 null 가능 여부를 판단할 수가 없다. 
 > 하지만 코틀린은 이러한 플랫폼 타입을 컴파일 에러가 아닌 런타임 에러로 잡아주기 때문에 플랫폼 타입에 대한 고려를 하지 않으면 NPE를 발생시키는 지점이 될 위험이 있다.
