---
layout: post
categories: MySQL
tags: MySQL
---

## 트랜잭션
트랜잭션은 작업의 완전성을 보장하는 것을 의미합니다. 논리적인 작업 셋이 정상적으로 모두 처리가 완료되었다면 그 때 커밋을 통해 데이터
변경을 이뤄지도록 하거나 중간에 하나의 쿼리라도 에러가 발생했다면 작업 시작 이전의 상태로 원복시키는 것이 트랜잭션의 역할입니다.
즉, 논리적인 작업 셋의 내용이 완전히 적용되거나 그렇지 않다면 아예 적용되지 않은 상태로 유지하는 것을 보장하는 것(정합성을 보장하는
것)이 트랜잭션입니다.

## 격리 수준
여러 트랜잭션에서 동시에 같은 테이블의 row에 접근하는 경우 각 트랜잭션 사이에서 작업 내용을 어떻게 공유하고 차단할건지에 대한 레벨을
격리 수준이라고 합니다.
즉, 특정 트랜잭션이 다른 트랜잭션에서 조회, 변경하는 데이터에 대한 접근 허용 범위를 결정하는 것이 격리 수준이라 생각할 수 있습니다.

격리 수준의 종류는 아래와 같이 4가지로 분류됩니다.(격리 수준은 아래로 갈수록 엄격해집니다.)

- READ UNCOMMITTED
- READ COMMITTED
- REPEATABLE READ
- SERIALIZABLE

각각의 격리 수준의 특징과 발생할 수 있는 문제점을 알아보겠습니다.

### READ UNCOMMITTED
아직 커밋되지 않은 레코드도 다른 트랜잭션에서 조회 가능한 정도의 격리 수준을 의미합니다.

READ UNCOMMITTED에서는 DIRTY READ가 발생합니다. DIRTY READ 라는 것은 아직 커밋되지 않은 데이터를 다른 트랜잭션에서 조회
하는 것을 의미합니다. DIRTY READ가 발생하면 데이터가 원복되어도 이미 해당 데이터를 조회한 트랜잭션은 원복 사실을 알지 못하고 데이터
정합성이 깨지는 문제를 발생히시킬 수 있습니다.

### READ COMMITTED
트랜잭션에서 커밋된 내용에 대해서 다른 트랜잭션이 조회가 가능한 정도의 격리 수준을 의미합니다.
READ COMMITTED에선 DIRTY READ가 발생하진 않지만 NON-REPEATABLE READ 문제가 발생합니다.
NON-REPEATABLE READ 문제란 하나의 트랜잭션이 끝나지 않은 상황에서 다른 트랜잭션이 특정 데이터를 변경한 경우, 변경 전과 변경 후에
조회되는 데이터의 결과가 다른 것을 의미합니다.
이는 하나의 트랜잭션에서 동작하는 하나의 쿼리가 다른 값을 조회하게 되는 문제가 발생합니다.(READABLE READ 정합성에서 어긋남)

### REPEATABLE READ
NON-REPEATABLE READ 문제를 해결하기 위해 트랜잭션 번호를 부여하고 하나의 트랜잭션이 부여받은 번호보다 높은 번호의 트랜잭션에서
변경한 내용은 접근하지 못하는 격리 수준을 의미합니다.
이렇게 된다면 먼저 시작한 트랜잭션에선 나중에 시작한 트랜잭션의 변경내용을 확인할 수 없기 때문에 REPEATABLE READ 정합성을 지킬 수 있습니다.

> MySQL 에서 READ COMMITED와 REPEATABLE READ 는 데이터 변경이 발생할 때 언두 로그에 백업 데이터를 생성해두고 실제 데이터를 변경합니다.
> 그래서 커밋 이전에 변경된 데이터에 대해서 다른 트랜잭션은 언두 로그를 통해 변경 이전의 데이터에 접근하지만 커밋 이후에는 실제 데이터를 조회하게 됩니다.
> 이 부분에서 두 격리 수준의 차이가 발생합니다.
>
> READ COMMITED : 커밋 이후 실제 데이터로만 접근 <br>
> REPEATABLE READ : 트랜잭션 번호를 통해 번호가 작은 데이터에만 접근, 커밋된 이후 실제 데이터 트랜잭션번호가 크다면 언두로그의 백업 데이터에서 조회

REAPEATABLE READ에선 INSERT된 데이터에 대해서 정합성을 지키지 못하는 경우가 생깁니다. 특정 범위 조건에 부합하는 데이터 리스트
를 조회할 경우, 다른 트랜잭션에서 추가한 데이터가 같은 쿼리에서 보였다 안보였다 하는 문제가 발생할 수 있는데 이를 PHANTOM READ
라고 합니다.

### SERIALIZABLE
가장 엄격한 격리 수준으로 하나의 트랜잭션이 끝날 때까지 해당 트랜잭션에서 사용하는 레코드에 대한 읽기, 쓰기 권한을 제한하는 것을 의미합니다.
SERIALIZABLE에선 PHANTOM READ이 발생하지 않습니다.

## 참고자료
- [https://nesoy.github.io/articles/2019-05/Database-Transaction-isolation](https://nesoy.github.io/articles/2019-05/Database-Transaction-isolation)
